{"version":3,"file":"spritesheet.min.js","sources":["../src/Spritesheet.ts","../src/SpritesheetLoader.ts"],"sourcesContent":["import { Rectangle } from '@pixi/math';\nimport { Texture, BaseTexture } from '@pixi/core';\nimport { getResolutionOfUrl } from '@pixi/utils';\nimport type { Dict } from '@pixi/utils';\nimport type { resources } from '@pixi/core';\nimport type { IPointData } from '@pixi/math';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n */\nexport interface ISpritesheetFrameData {\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    trimmed?: boolean;\n    rotated?: boolean;\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    spriteSourceSize?: {\n        x: number;\n        y: number;\n    };\n    anchor?: IPointData;\n}\n\n/**\n * Atlas format.\n */\nexport interface ISpritesheetData {\n    frames: Dict<ISpritesheetFrameData>;\n    animations?: Dict<string[]>;\n    meta: {\n        scale: string;\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\nexport class Spritesheet\n{\n    /**\n     * The maximum number of Textures to build per process.\n     *\n     * @type {number}\n     * @default 1000\n     */\n    static readonly BATCH_SIZE = 1000;\n\n    public baseTexture: BaseTexture;\n    public textures: Dict<Texture>;\n    public animations: Dict<Texture[]>;\n    public data: ISpritesheetData;\n    public resolution: number;\n\n    private _texture: Texture;\n    private _frames: Dict<ISpritesheetFrameData>;\n    private _frameKeys: string[];\n    private _batchIndex: number;\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /**\n     * @param {PIXI.BaseTexture|PIXI.Texture} baseTexture - Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param {string} [resolutionFilename] - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    constructor(texture: BaseTexture | Texture, data: ISpritesheetData, resolutionFilename: string = null)\n    {\n        /**\n         * Reference to original source image from the Loader. This reference is retained so we\n         * can destroy the Texture later on. It is never used internally.\n         * @type {PIXI.Texture}\n         * @private\n         */\n        this._texture = texture instanceof Texture ? texture : null;\n\n        /**\n         * Reference to ths source texture.\n         * @type {PIXI.BaseTexture}\n         */\n        this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n\n        /**\n         * A map containing all textures of the sprite sheet.\n         * Can be used to create a {@link PIXI.Sprite|Sprite}:\n         * ```js\n         * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n         * ```\n         * @member {Object}\n         */\n        this.textures = {};\n\n        /**\n         * A map containing the textures for each animation.\n         * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n         * ```js\n         * new PIXI.AnimatedSprite(sheet.animations[\"anim_name\"])\n         * ```\n         * @member {Object}\n         */\n        this.animations = {};\n\n        /**\n         * Reference to the original JSON data.\n         * @type {Object}\n         */\n        this.data = data;\n\n        const resource = this.baseTexture.resource as resources.ImageResource;\n\n        /**\n         * The resolution of the spritesheet.\n         * @type {number}\n         */\n        this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n\n        /**\n         * Map of spritesheet frames.\n         * @type {Object}\n         * @private\n         */\n        this._frames = this.data.frames;\n\n        /**\n         * Collection of frame names.\n         * @type {string[]}\n         * @private\n         */\n        this._frameKeys = Object.keys(this._frames);\n\n        /**\n         * Current batch index being processed.\n         * @type {number}\n         * @private\n         */\n        this._batchIndex = 0;\n\n        /**\n         * Callback when parse is completed.\n         * @type {Function}\n         * @private\n         */\n        this._callback = null;\n    }\n\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     *\n     * @private\n     * @param {string} resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @return {number} Resolution to use for spritesheet.\n     */\n    private _updateResolution(resolutionFilename: string = null): number\n    {\n        const { scale } = this.data.meta;\n\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        let resolution = getResolutionOfUrl(resolutionFilename, null);\n\n        // No resolution found via URL\n        if (resolution === null)\n        {\n            // Use the scale value or default to 1\n            resolution = scale !== undefined ? parseFloat(scale) : 1;\n        }\n\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1)\n        {\n            this.baseTexture.setResolution(resolution);\n        }\n\n        return resolution;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     *\n     * @param {Function} callback - Callback when complete returns\n     *        a map of the Textures for this spritesheet.\n     */\n    public parse(callback: () => void): void\n    {\n        this._batchIndex = 0;\n        this._callback = callback;\n\n        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n        {\n            this._processFrames(0);\n            this._processAnimations();\n            this._parseComplete();\n        }\n        else\n        {\n            this._nextBatch();\n        }\n    }\n\n    /**\n     * Process a batch of frames\n     *\n     * @private\n     * @param {number} initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture(\n                    this.baseTexture,\n                    frame,\n                    orig,\n                    trim,\n                    data.rotated ? 2 : 0,\n                    data.anchor\n                );\n\n                // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n                Texture.addToCache(this.textures[i], i);\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /**\n     * Parse animations config\n     *\n     * @private\n     */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /**\n     * The parse has completed.\n     *\n     * @private\n     */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /**\n     * Begin the next batch of textures.\n     *\n     * @private\n     */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     *\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.baseTexture.destroy();\n        }\n        this._texture = null;\n        this.baseTexture = null;\n    }\n}\n","import { url } from '@pixi/utils';\nimport { Spritesheet } from './Spritesheet';\nimport { LoaderResource } from '@pixi/loaders';\nimport type { Loader, ILoaderResource } from '@pixi/loaders';\n\n/**\n * {@link PIXI.Loader Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * @class\n * @memberof PIXI\n * @implements PIXI.ILoaderPlugin\n */\nexport class SpritesheetLoader\n{\n    /**\n     * Called after a resource is loaded.\n     * @see PIXI.Loader.loaderMiddleware\n     * @param {PIXI.LoaderResource} resource\n     * @param {function} next\n     */\n    static use(resource: ILoaderResource, next: (...args: unknown[]) => void): void\n    {\n        // because this is middleware, it execute in loader context. `this` = loader\n        const loader = (this as any) as Loader;\n        const imageResourceName = `${resource.name}_image`;\n\n        // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n        if (!resource.data\n            || resource.type !== LoaderResource.TYPE.JSON\n            || !resource.data.frames\n            || loader.resources[imageResourceName]\n        )\n        {\n            next();\n\n            return;\n        }\n\n        const loadOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata.imageMetadata,\n            parentResource: resource,\n        };\n\n        const resourcePath = SpritesheetLoader.getResourcePath(resource, loader.baseUrl);\n\n        // load the image for this sheet\n        loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res: ILoaderResource)\n        {\n            if (res.error)\n            {\n                next(res.error);\n\n                return;\n            }\n\n            const spritesheet = new Spritesheet(\n                res.texture,\n                resource.data,\n                resource.url\n            );\n\n            spritesheet.parse(() =>\n            {\n                resource.spritesheet = spritesheet;\n                resource.textures = spritesheet.textures;\n                next();\n            });\n        });\n    }\n\n    /**\n     * Get the spritesheets root path\n     * @param {PIXI.LoaderResource} resource - Resource to check path\n     * @param {string} baseUrl - Base root url\n     */\n    static getResourcePath(resource: ILoaderResource, baseUrl: string): string\n    {\n        // Prepend url path unless the resource image is a data url\n        if (resource.isDataUrl)\n        {\n            return resource.data.meta.image;\n        }\n\n        return url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);\n    }\n}\n"],"names":["texture","data","resolutionFilename","this","_texture","Texture","baseTexture","BaseTexture","textures","animations","resource","resolution","_updateResolution","url","_frames","frames","_frameKeys","Object","keys","_batchIndex","_callback","Spritesheet","scale","meta","getResolutionOfUrl","undefined","parseFloat","setResolution","callback","length","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","i","rect","frame","trim","sourceSize","trimmed","orig","Rectangle","Math","floor","w","h","rotated","x","y","spriteSourceSize","anchor","addToCache","animName","frameName","push","call","setTimeout","_this","destroyBase","destroy","SpritesheetLoader","next","imageResourceName","name","type","LoaderResource","TYPE","JSON","resources","loadOptions","crossOrigin","metadata","imageMetadata","parentResource","resourcePath","getResourcePath","baseUrl","add","res","error","spritesheet","parse","isDataUrl","image","resolve","replace"],"mappings":"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"}