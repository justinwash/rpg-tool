{"version":3,"file":"canvas-graphics.min.js","sources":["../src/Graphics.ts","../src/CanvasGraphicsRenderer.ts"],"sourcesContent":["import { Graphics } from '@pixi/graphics';\nimport { CanvasRenderer } from '@pixi/canvas-renderer';\nimport { RenderTexture, Texture } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\n\nimport type { SCALE_MODES } from '@pixi/constants';\nimport type { BaseRenderTexture } from '@pixi/core';\n\nlet canvasRenderer: CanvasRenderer;\nconst tempMatrix = new Matrix();\n\n/**\n * Generates a canvas texture. Only available with **pixi.js-legacy** bundle\n * or the **@pixi/canvas-graphics** package.\n * @method generateCanvasTexture\n * @memberof PIXI.Graphics#\n * @param {PIXI.SCALE_MODES} scaleMode - The scale mode of the texture.\n * @param {number} resolution - The resolution of the texture.\n * @return {PIXI.Texture} The new texture.\n */\nGraphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode: SCALE_MODES, resolution = 1): Texture\n{\n    const bounds = this.getLocalBounds();\n\n    const canvasBuffer = RenderTexture.create({\n        width: bounds.width,\n        height: bounds.height,\n        scaleMode,\n        resolution,\n    });\n\n    if (!canvasRenderer)\n    {\n        canvasRenderer = new CanvasRenderer();\n    }\n\n    this.transform.updateLocalTransform();\n    this.transform.localTransform.copyTo(tempMatrix);\n\n    tempMatrix.invert();\n\n    tempMatrix.tx -= bounds.x;\n    tempMatrix.ty -= bounds.y;\n\n    canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n\n    const texture = Texture.from((canvasBuffer.baseTexture as BaseRenderTexture)._canvasRenderTarget.canvas, {\n        scaleMode,\n    });\n\n    texture.baseTexture.setResolution(resolution);\n\n    return texture;\n};\n\nGraphics.prototype.cachedGraphicsData = [];\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @method _renderCanvas\n * @memberof PIXI.Graphics#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nGraphics.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    if (this.isMask === true)\n    {\n        return;\n    }\n\n    this.finishPoly();\n    renderer.plugins.graphics.render(this);\n};\n","import { Texture } from '@pixi/core';\nimport { SHAPES, Matrix } from '@pixi/math';\nimport { canvasUtils } from '@pixi/canvas-renderer';\n\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { FillStyle, Graphics } from '@pixi/graphics';\nimport type { Polygon, Rectangle, Circle, Ellipse, RoundedRectangle } from '@pixi/math';\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasGraphicsRenderer\n{\n    public renderer: CanvasRenderer;\n    private _svgMatrix: DOMMatrix|boolean;\n    private _tempMatrix: Matrix;\n\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - The current PIXI renderer.\n     */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n        this._svgMatrix = null;\n        this._tempMatrix = new Matrix();\n    }\n\n    /**\n     * calculates fill/stroke style for canvas\n     *\n     * @private\n     * @param {PIXI.FillStyle} style\n     * @param {number} tint\n     * @returns {string|CanvasPattern}\n     */\n    private _calcCanvasStyle(style: FillStyle, tint: number): string|CanvasPattern\n    {\n        let res;\n\n        if (style.texture && style.texture.baseTexture !== Texture.WHITE.baseTexture)\n        {\n            if (style.texture.valid)\n            {\n                res = canvasUtils.getTintedPattern(style.texture, tint);\n                this.setPatternTransform(res, style.matrix || Matrix.IDENTITY);\n            }\n            else\n            {\n                res = '#808080';\n            }\n        }\n        else\n        {\n            res = `#${(`00000${(tint | 0).toString(16)}`).substr(-6)}`;\n        }\n\n        return res;\n    }\n\n    /**\n     * Renders a Graphics object to a canvas.\n     *\n     * @param {PIXI.Graphics} graphics - the actual graphics object to render\n     */\n    public render(graphics: Graphics): void\n    {\n        const renderer = this.renderer;\n        const context = renderer.context;\n        const worldAlpha = graphics.worldAlpha;\n        const transform = graphics.transform.worldTransform;\n\n        renderer.setContextTransform(transform);\n        renderer.setBlendMode(graphics.blendMode);\n\n        const graphicsData = graphics.geometry.graphicsData;\n\n        let contextFillStyle;\n        let contextStrokeStyle;\n\n        const tintR = ((graphics.tint >> 16) & 0xFF) / 255;\n        const tintG = ((graphics.tint >> 8) & 0xFF) / 255;\n        const tintB = (graphics.tint & 0xFF) / 255;\n\n        for (let i = 0; i < graphicsData.length; i++)\n        {\n            const data = graphicsData[i];\n            const shape = data.shape;\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            const fillColor = data.fillStyle.color | 0;\n            const lineColor = data.lineStyle.color | 0;\n\n            if (data.matrix)\n            {\n                renderer.setContextTransform(transform.copyTo(this._tempMatrix).append(data.matrix));\n            }\n\n            if (fillStyle.visible)\n            {\n                const fillTint = (\n                    (((fillColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                    + (((fillColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                    + (((fillColor & 0xFF) / 255) * tintB * 255)\n                );\n\n                contextFillStyle = this._calcCanvasStyle(fillStyle, fillTint);\n            }\n            if (lineStyle.visible)\n            {\n                const lineTint = (\n                    (((lineColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                    + (((lineColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                    + (((lineColor & 0xFF) / 255) * tintB * 255)\n                );\n\n                contextStrokeStyle = this._calcCanvasStyle(lineStyle, lineTint);\n            }\n\n            context.lineWidth = lineStyle.width;\n            context.lineCap = lineStyle.cap;\n            context.lineJoin = lineStyle.join;\n            context.miterLimit = lineStyle.miterLimit;\n\n            if (data.type === SHAPES.POLY)\n            {\n                context.beginPath();\n\n                const tempShape = shape as Polygon;\n                let points = tempShape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n                let px;\n                let py;\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                if (tempShape.closeStroke)\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    outerArea = 0;\n                    px = points[0];\n                    py = points[1];\n                    for (let j = 2; j + 2 < points.length; j += 2)\n                    {\n                        outerArea += ((points[j] - px) * (points[j + 3] - py))\n                            - ((points[j + 2] - px) * (points[j + 1] - py));\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = (holes[k].shape as Polygon).points;\n\n                        if (!points)\n                        {\n                            continue;\n                        }\n\n                        innerArea = 0;\n                        px = points[0];\n                        py = points[1];\n                        for (let j = 2; j + 2 < points.length; j += 2)\n                        {\n                            innerArea += ((points[j] - px) * (points[j + 3] - py))\n                                - ((points[j + 2] - px) * (points[j + 1] - py));\n                        }\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            context.moveTo(points[0], points[1]);\n\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n                            for (let j = points.length - 4; j >= 0; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n\n                        if ((holes[k].shape as Polygon).closeStroke)\n                        {\n                            context.closePath();\n                        }\n                    }\n                }\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                const tempShape = shape as Rectangle;\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fillRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.strokeRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);\n                }\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                const tempShape = shape as Circle;\n\n                // TODO - need to be Undefined!\n                context.beginPath();\n                context.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n                const tempShape = shape as Ellipse;\n\n                const w = tempShape.width * 2;\n                const h = tempShape.height * 2;\n\n                const x = tempShape.x - (w / 2);\n                const y = tempShape.y - (h / 2);\n\n                context.beginPath();\n\n                const kappa = 0.5522848;\n                const ox = (w / 2) * kappa; // control point offset horizontal\n                const oy = (h / 2) * kappa; // control point offset vertical\n                const xe = x + w; // x-end\n                const ye = y + h; // y-end\n                const xm = x + (w / 2); // x-middle\n                const ym = y + (h / 2); // y-middle\n\n                context.moveTo(x, ym);\n                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const tempShape = shape as RoundedRectangle;\n\n                const rx = tempShape.x;\n                const ry = tempShape.y;\n                const width = tempShape.width;\n                const height = tempShape.height;\n                let radius = tempShape.radius;\n\n                const maxRadius = Math.min(width, height) / 2 | 0;\n\n                radius = radius > maxRadius ? maxRadius : radius;\n\n                context.beginPath();\n                context.moveTo(rx, ry + radius);\n                context.lineTo(rx, ry + height - radius);\n                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n                context.lineTo(rx + width - radius, ry + height);\n                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n                context.lineTo(rx + width, ry + radius);\n                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n                context.lineTo(rx + radius, ry);\n                context.quadraticCurveTo(rx, ry, rx, ry + radius);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n        }\n    }\n\n    public setPatternTransform(pattern: CanvasPattern, matrix: Matrix): void\n    {\n        if (this._svgMatrix === false)\n        {\n            return;\n        }\n        if (!this._svgMatrix)\n        {\n            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n            if (svg && svg.createSVGMatrix)\n            {\n                this._svgMatrix = svg.createSVGMatrix();\n            }\n            if (!this._svgMatrix || !pattern.setTransform)\n            {\n                this._svgMatrix = false;\n\n                return;\n            }\n        }\n\n        (this._svgMatrix as DOMMatrix).a = matrix.a;\n        (this._svgMatrix as DOMMatrix).b = matrix.b;\n        (this._svgMatrix as DOMMatrix).c = matrix.c;\n        (this._svgMatrix as DOMMatrix).d = matrix.d;\n        (this._svgMatrix as DOMMatrix).e = matrix.tx;\n        (this._svgMatrix as DOMMatrix).f = matrix.ty;\n        pattern.setTransform((this._svgMatrix as DOMMatrix).inverse());\n    }\n    /**\n     * destroy graphics object\n     *\n     */\n    public destroy(): void\n    {\n        this.renderer = null;\n        this._svgMatrix = null;\n        this._tempMatrix = null;\n    }\n}\n"],"names":["canvasRenderer","renderer","this","_svgMatrix","_tempMatrix","Matrix","CanvasGraphicsRenderer","style","tint","res","texture","baseTexture","Texture","WHITE","valid","canvasUtils","getTintedPattern","setPatternTransform","matrix","IDENTITY","toString","substr","graphics","context","worldAlpha","transform","worldTransform","setContextTransform","setBlendMode","blendMode","contextFillStyle","contextStrokeStyle","graphicsData","geometry","tintR","tintG","tintB","i","length","data","shape","fillStyle","lineStyle","fillColor","color","lineColor","copyTo","append","visible","fillTint","_calcCanvasStyle","lineTint","lineWidth","width","lineCap","cap","lineJoin","join","miterLimit","type","SHAPES","POLY","beginPath","points","tempShape","holes","outerArea","innerArea","px","py","moveTo","j","lineTo","closeStroke","closePath","k","globalAlpha","alpha","fill","strokeStyle","stroke","RECT","fillRect","x","y","height","strokeRect","CIRC","arc","radius","Math","PI","ELIP","w","h","ox","oy","xe","ye","xm","ym","bezierCurveTo","RREC","rx","ry","maxRadius","min","quadraticCurveTo","pattern","svg","document","createElementNS","createSVGMatrix","setTransform","a","b","c","d","e","tx","f","ty","inverse","tempMatrix","prototype","generateCanvasTexture","scaleMode","resolution","bounds","getLocalBounds","canvasBuffer","RenderTexture","create","CanvasRenderer","updateLocalTransform","localTransform","invert","render","from","_canvasRenderTarget","canvas","setResolution","cachedGraphicsData","_renderCanvas","isMask","finishPoly","plugins"],"mappings":"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"}